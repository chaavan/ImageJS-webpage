<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ImageJS Feature Explorer</title>
  <link rel="icon" href="data:," />
  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>ImageJS Feature Explorer</h1>
  <div id="controls">
    <label for="fileInput">Upload Image:</label>
    <input type="file" id="fileInput" accept="image/*" />

    <label for="featureSelect">Select Feature:</label>
    <select id="featureSelect" disabled>
      <option value="">-- Choose a feature --</option>
    </select>
  </div>

  <canvas id="my_canvas"></canvas>

  <script type="module">
    import * as IJ from 'image-js';
    const { Image } = IJ;

    const featureDefinitions = {
      Filters: ['invert', 'grey', 'blur', 'gaussianBlur', 'median', 'gradient', 'derivative', 'pixelate', 'level'],
      Comparison: ['subtract', 'and', 'or', 'xor', 'difference'],
      Geometry: ['rotate', 'resize', 'crop', 'pad', 'flipX', 'flipY'],
      Morphology: ['erode', 'dilate', 'open', 'close', 'skeleton', 'topHat', 'gradient', 'distanceMap'],
      Operations: ['threshold', 'getHistogram', 'mask', 'extractChannel', 'paste', 'splitChannels'],
      ROI: ['autoCrop', 'fromMask', 'getBoundingBox', 'cropByROI', 'clearBorder', 'fillRoi', 'invertRoi', 'roiToMask', 'extractRoi', 'projectRoi', 'paintRoi', 'sampleRoi', 'smoothRoi']
    };

    const fileInput = document.getElementById('fileInput');
    const featureSelect = document.getElementById('featureSelect');
    const canvas = document.getElementById('my_canvas');
    const ctx = canvas.getContext('2d');
    let origImage = null;

    function buildFeatureList() {
      featureSelect.innerHTML = '<option value="">-- Choose a feature --</option>';
      for (const [category, methods] of Object.entries(featureDefinitions)) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        methods.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          optgroup.appendChild(opt);
        });
        featureSelect.appendChild(optgroup);
      }
    }

    function drawImage(img) {
      const w = img.width;
      const h = img.height;
      const data = img.data;
      const channels = data.length / (w * h);
      let rgba;

      if (channels === 1) {
        rgba = new Uint8ClampedArray(w * h * 4);
        for (let i = 0; i < w * h; i++) {
          const v = data[i];
          const j = i * 4;
          rgba[j] = v;
          rgba[j+1] = v;
          rgba[j+2] = v;
          rgba[j+3] = 255;
        }
      } else if (channels === 3) {
        rgba = new Uint8ClampedArray(w * h * 4);
        for (let i = 0; i < w * h; i++) {
          const j3 = i * 3, j4 = i * 4;
          rgba[j4] = data[j3];
          rgba[j4+1] = data[j3+1];
          rgba[j4+2] = data[j3+2];
          rgba[j4+3] = 255;
        }
      } else if (channels === 4) {
        rgba = new Uint8ClampedArray(data);
      } else {
        throw new Error('Unsupported channel count: ' + channels);
      }

      canvas.width = w;
      canvas.height = h;
      ctx.putImageData(new ImageData(rgba, w, h), 0, 0);
    }

    buildFeatureList();

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files[0];
      if (!file) return;
      const buf = await file.arrayBuffer();
      origImage = await Image.load(buf);
      drawImage(origImage);
      featureSelect.disabled = false;
      featureSelect.value = '';
    });

    featureSelect.addEventListener('change', () => {
      const feat = featureSelect.value;
      if (!feat || !origImage) return;
      const input = prompt(`Enter JSON args for '${feat}' or leave blank:`);
      let args;
      if (input) {
        try { args = JSON.parse(input); }
        catch (e) { return alert('Invalid JSON: ' + e.message); }
      }
      try {
        const result = args ? origImage[feat](args) : origImage[feat]();
        drawImage(result);
      } catch (err) {
        alert(`Failed to run ${feat}: ${err.message}`);
      }
    });
  </script>
</body>
</html>